## Dates & Times ##
All versions of HEC-DSS have used integer values to represent dates and times. Originally, the values represented
minutes after 30Dec1899 24:00/31Dec1899 00:00. Subsequently, the integer size has settled at 32 bits, and additional
information was added to specify whether the values indicated seconds, minutes, hours, or days - each with their own
zero-time. The Java class `hec.heclib.util.HecTime` has been used to bind all of this together. However, I have found
no time library for any programming language that encompasses the vast date range available to `HecTime` on one extreme
while allowing minute or second granularity on the other. Issues with `HecTime` include:
* Opaque values - the integers generated by `HecTime`, unless converted to date/time strings (with the necessary
  granularity information, which is often not obvious), are meaningless to humans.
* Language bound - although the `HecTime` has now been ported to pure python, there's no available complete
  implementation for .net or native code.

For SQLDSS I decided to use 64-bit integers to store date/time values in an encoded format which provides vast
date ranges, seconds granularity, and human-readable values. In this format:
* <span style="color: red;">The rightmost two digits are the second of the minute.</span>
* <span style="color: yellow;">The next rightmost two digits are the minute of the hour.</span>
* <span style="color: green;">The next rightmost two digits are the hour of the day.</span>
* <span style="color: blue;">The next rightmost two digits are the day of the month.</span>
* <span style="color: violet;">The next rightmost two digits are the month of the year.</span>
* All digits left of the rightmost 10 are the year.

Thus, 20260211144700 is 11Feb2026 14:47:00, and -23975640101000000 is 01Jan of the year -2397564 in the proleptic
Gregorian calendar. In date-only contexts (e.g, block start dates), the right-most six digits are removed, leaving
eight digits for 4-digit year dates.
                                    
Benefits of this format are:
* The values are unambiguous - the integer value contains all necessary information
* The values are natively comparable
* Composition and decomposition involve only integer arithmetic and are thus highly performant and easily implementable
in any programming language.

No time zone information is stored in SQLDSS; all date/time values are expected to be in UTC or to be naive of time zone.



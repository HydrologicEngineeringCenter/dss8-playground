# SQLDSS (HEC-DSS v8) #
## Overview ##
SQLDSS (aka HEC-DSS v8) is a new implementation of the HEC Data Storage System built
on a foundation of SQLite. In this implementation the internally developed data storage engine (data formats,
locations, and access methods) is replaced with the externally maintained and widely used SQLite file format
and access libraries.

To the extent practical, all data is stored as columns in relational tables and is may be accessed via
SQL, whether via either programming language-specific library or the `sqlite3` command line utility. However,
for performance reasons some data is stored in BLOB columns and requires custom packing/unpacking, making
such data opaque to `sqlite3`. The table structure is inspired by the CWMS database structure, although the
SQLDSS version is simplified. See the [TABLE_STRUCTURE](tables/TABLE_STRUCTURE.md) document for details of
the relational tables.

The only data type currently supported is regular time series, although adding irregular time series should
not be complicated.

## Dates & Times ##
All versions of HEC-DSS have used integer values to represent dates and times. Originally, the values represented
minutes after 30Dec1899 24:00/31Dec1899 00:00. Subsequently, the integer size has settled at 32 bits, and additional
information was added to specify whether the values indicated seconds, minutes, hours, or days - each with their own
zero-time. The Java class `hec.heclib.util.HecTime` has been used to bind all of this together. However, I have found
no time library for any programming language that encompasses the vast date range available to `HecTime` on one extreme
while allowing minute or second granularity on the other. Issues with `HecTime` include:
* Opaque values - the integers generated by `HecTime`, unless converted to date/time strings (with the necessary
  granularity information, which is often not obvious), are meaningless to humans.
* Language bound - although the `HecTime` has now been ported to pure python, there's no available complete
  implementation for .net or native code.

For SQLDSS I decided to use 64-bit integers to store date/time values in an encoded for which provides vast
date ranges, seconds granularity, and human-readable values. In this format:
* The rightmost two digits are the second of the minute.
* The next rightmost two digits are the minute of the hour.
* The next rightmost two digits are the hour of the day.
* The next rightmost two digits are the day of the month.
* The next rightmost two digits are the month of the year.
* All digits left of the rightmost 10 are the year.

Thus, 20260211144700 is 11Feb2026 14:47:00, and -2397560101000000 is 01Jan of the year -239756 in the proleptic
Gregorian calendar.

Composition and decomposition of these date/time object involve only integer arithmetic and thus highly performant.

## Core vs API Layers ##
When reimplementing something like HEC-DSS, attention must be paid to backward compatibility as well as improvement.
While the core of SQLDSS (even above the SQLite engine) is different, API translation layers can make it easier to
use the new code with existing software without major re-writes. The Java implementation of SQLDSS provides the 
class `mil.army.usace.hec.sqldss.api.dss7.HecDss` which provides essentially the same API as `hec.heclib.dss.HecDss`
class. Likewise, a `HecTimeSeries` class is also planned.

Other API layers could make it possible to use a CWMS database API or a URL API (Ã  la CDA) without change to the core.

## Data Names ##
SQLDSS doesn't adhere to the conventional HEC-DSS pathname structure, as in the CWMS database, and different data types
are free to have different naming conventions. If an API layer is used, it is responsible for translation between the
API-centric names and the core SQLDSS names.

### Location Names ###
Like CWMS, SQLDSS uses base locations and sub-locations, separated by the first hyphen `-`character. Base locations
comprise an optional context, which appears before the base-location name and is separated by a colon `:` character.
* *context*`:`*base_location*`-`*sub_location*
* *context*`:`*base_location*
* *base_location*
* *base_location*`-`*sub_location*

The only constraints on location names are:
* Neither of `:`, `-` may appear in a context.
* `-` may not appear in a base location

SQLDSS imposes no meaning on the context. The DSS7 API layer maps it to the A pathname part, while a CWMS API layer
might map it to an office.

### Parameter Names ###
Like CWMS, SQLDSS uses base locations and sub-locations, separated by the first hyphen `-`character. Base parameters
are constrained by the [BASE_PARAMETER](tables/BASE_PARAMETER.md) table; sub-parameters are unconstrained.

### Parameter Type Names ###
SQLDSS parameter types are a superset of HEC-DSS v7 data types:


